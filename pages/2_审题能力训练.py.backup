# pages/2_审题能力训练.py
import streamlit as st
from modules.comprehension_logic import load_problems
import json
import time
import re

# --- 页面配置 ---
st.set_page_config(page_title="审题能力训练", page_icon="✍️")
st.title("✍️ 审题能力训练")


# --- 辅助函数 ---
def get_answer_letters(selection):
    """从用户的选择（字符串或列表）中提取出大写字母答案。"""
    if not selection:
        return []

    if isinstance(selection, str):
        selection = [selection]

    letters = []
    for item in selection:
        match = re.match(r"([A-Z])", item)
        if match:
            letters.append(match.group(1))
    return sorted(letters)


def display_feedback_for_step(step_name, problem_data, user_answers_data, step_results_data):
    """一个专门用于显示每一步反馈的函数，以提供更丰富的上下文。"""

    # 提取所需信息
    question = problem_data[f'{step_name}_Question']
    all_options = str(problem_data[f'{step_name}_Options']).split('|')
    step_result = step_results_data.get(step_name, {})

    user_letters = step_result.get('user_letters', [])
    correct_letters = step_result.get('correct_answers', [])
    is_correct = step_result.get('correct', False)

    st.markdown("---")
    st.markdown(
        f"**{['一', '二', '三', '四'][['Goal', 'Extraction', 'Rule', 'Strategy'].index(step_name)]}、{question}**")

    # 逐一渲染所有选项，并标记用户选择和正确性
    for option in all_options:
        option_letter = get_answer_letters(option)[0]
        is_selected = option_letter in user_letters
        is_correct_option = option_letter in correct_letters

        # 根据状态选择不同的图标和格式
        if is_selected and is_correct_option:
            st.markdown(f"🔵 **{option}** (你的选择 - 正确)")
        elif is_selected and not is_correct_option:
            st.markdown(f"🔴 **{option}** (你的选择 - 错误)")
        elif not is_selected and is_correct_option:
            st.markdown(f"✅ **{option}** (正确答案)")
        else:
            st.markdown(f"⚪ {option}")

    # 显示总体对错判断和来自Feedback_Column的建议
    if is_correct:
        st.success("✅ **回答正确**")
    else:
        st.error("❌ **回答错误**")

        # 解析并显示Feedback_Column中的具体建议
        try:
            feedback_data = json.loads(problem_data['Feedback_Column'])

            # 找出所有错误相关的选项字母（选了但错误 + 没选但正确）
            error_related_letters = set(user_letters).symmetric_difference(set(correct_letters))

            for letter in error_related_letters:
                feedback_key = f"{step_name}_{letter}"
                if feedback_key in feedback_data:
                    st.warning(f"💡 **针对选项 {letter} 的建议:** {feedback_data[feedback_key]}")

        except (json.JSONDecodeError, KeyError):
            # 如果Feedback_Column为空或格式错误，则不显示建议
            pass


# --- 状态初始化 ---
# (保持不变)
if 'comp_level' not in st.session_state:
    st.session_state.comp_level = 0
    st.session_state.problems = []
    st.session_state.current_problem_index = 0
    st.session_state.session_correct_subquestion_count = 0
    st.session_state.session_problem_count = 0
    st.session_state.submitted = False
    st.session_state.timed_out = False
    st.session_state.comp_start_time = 0
    st.session_state.user_answers_for_feedback = {}
    st.session_state.step_results = {}

# --- 页面逻辑 ---

# 难度选择
# (保持不变)
if st.session_state.comp_level == 0:
    st.info("请选择难度开始训练。每轮训练包含3道题目，每题都有时间限制。")
    level_options = {1: "等级 1 (每题60秒)", 2: "等级 2 (每题90秒)", 3: "等级 3 (每题120秒)"}
    level = st.selectbox("选择难度等级", options=list(level_options.keys()), format_func=lambda x: level_options[x])

    if st.button("开始新一轮训练"):
        problems = load_problems(level)
        if problems and len(problems) >= 3:
            # 重置所有状态
            st.session_state.comp_level = level
            st.session_state.problems = problems[:3]
            st.session_state.current_problem_index = 0
            st.session_state.session_correct_subquestion_count = 0
            st.session_state.session_problem_count = 0
            st.session_state.submitted = False
            st.session_state.timed_out = False
            st.session_state.comp_start_time = time.time()
            st.rerun()
        else:
            st.error("加载题库失败或题库题目不足3道，请检查data文件夹。")

# 训练总结
# (保持不变)
elif st.session_state.comp_level == -1:
    st.balloons()
    st.subheader("🎉 本轮训练已完成！")
    total_subquestions = st.session_state.session_problem_count * 4
    try:
        accuracy = st.session_state.session_correct_subquestion_count / total_subquestions
        st.metric("小题正确率", f"{accuracy:.1%}")
        st.info(
            f"在本轮总共 **{total_subquestions}** 道分析小题中，你答对了 **{st.session_state.session_correct_subquestion_count}** 道。")
    except ZeroDivisionError:
        st.warning("本轮未完成任何题目。")

    if st.button("再来一组！"):
        st.session_state.comp_level = 0
        st.rerun()

# 训练主界面
else:
    problem = st.session_state.problems[st.session_state.current_problem_index]
    time_limits = {1: 60, 2: 90, 3: 120}
    time_limit = time_limits[st.session_state.comp_level]

    # --- 计时器逻辑 (保持不变) ---
    if not st.session_state.submitted:
        # ... (此处代码省略，与上一版相同) ...
        time_elapsed = time.time() - st.session_state.comp_start_time
        time_left = time_limit - time_elapsed
        timer_placeholder = st.empty()
        timer_placeholder.progress(max(0, time_left) / time_limit, text=f"剩余时间: {max(0, int(time_left))} 秒")
        if time_left < 0:
            st.session_state.submitted = True
            st.session_state.timed_out = True
            st.rerun()

    # --- 界面布局 ---
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("题目原文")
        st.markdown(f"**第 {st.session_state.session_problem_count + 1} / 3 题** (ID: {problem['Problem_ID']})")
        st.markdown(problem['Problem_Text'])

    with col2:
        # --- 答题表单 ---
        if not st.session_state.submitted:
            st.subheader("请一次性完成以下所有分析步骤")
            with st.form(key='comprehension_form'):
                steps = ["Goal", "Extraction", "Rule", "Strategy"]
                questions = [problem[f'{s}_Question'] for s in steps]
                options_list = [str(problem[f'{s}_Options']).split('|') for s in steps]

                user_answers = {}
                user_answers['Goal'] = st.radio(f"**1. {questions[0]}**", options_list[0], key='goal_radio')
                user_answers['Extraction'] = st.multiselect(f"**2. {questions[1]}**", options_list[1], key='ext_multi')
                user_answers['Rule'] = st.multiselect(f"**3. {questions[2]}**", options_list[2], key='rule_multi')
                user_answers['Strategy'] = st.radio(f"**4. {questions[3]}**", options_list[3], key='strat_radio')

                submitted_button = st.form_submit_button("提交本题全部答案")

                if submitted_button:
                    st.session_state.submitted = True
                    st.session_state.user_answers_for_feedback = user_answers

                    # --- 提交时立即处理答案和分数 ---
                    step_results = {}
                    correct_sub_count_this_round = 0
                    for step in steps:
                        correct_answers = sorted(str(problem[f'{step}_Answer']).split('|'))
                        user_selection = user_answers.get(step, [])
                        user_letters = get_answer_letters(user_selection)

                        is_step_correct = (user_letters == correct_answers)
                        if is_step_correct:
                            correct_sub_count_this_round += 1

                        step_results[step] = {
                            "correct": is_step_correct,
                            "user_letters": user_letters,
                            "correct_answers": correct_answers
                        }

                    st.session_state.step_results = step_results
                    st.session_state.session_correct_subquestion_count += correct_sub_count_this_round
                    st.session_state.session_problem_count += 1
                    st.rerun()

        # --- 反馈界面 (重大修改) ---
        else:
            st.subheader("答案与解析")
            if st.session_state.timed_out:
                st.error("⌛️ 时间到！本题所有小题计为错误。")

            # 使用新的辅助函数来显示每一步的详细反馈
            for step in ["Goal", "Extraction", "Rule", "Strategy"]:
                display_feedback_for_step(
                    step_name=step,
                    problem_data=problem,
                    user_answers_data=st.session_state.get('user_answers_for_feedback', {}),
                    step_results_data=st.session_state.get('step_results', {})
                )

            st.markdown("---")


            # --- 流程控制按钮 ---
            def go_to_next_problem():
                if st.session_state.session_problem_count >= 3:
                    st.session_state.comp_level = -1
                else:
                    st.session_state.current_problem_index += 1
                    st.session_state.submitted = False
                    st.session_state.timed_out = False
                    st.session_state.step_results = {}
                    st.session_state.user_answers_for_feedback = {}
                    st.session_state.comp_start_time = time.time()


            st.button("进入下一题" if st.session_state.session_problem_count < 3 else "查看本轮总结",
                      on_click=go_to_next_problem)

    # 保持计时器UI实时刷新
    if not st.session_state.submitted and st.session_state.comp_level > 0:
        time.sleep(0.1)
        st.rerun()