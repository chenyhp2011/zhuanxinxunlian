# pages/2_å®¡é¢˜èƒ½åŠ›è®­ç»ƒ.py
import streamlit as st
from modules.comprehension_logic import load_problems
import json
import time
import re

# --- é¡µé¢é…ç½® ---
st.set_page_config(page_title="å®¡é¢˜èƒ½åŠ›è®­ç»ƒ", page_icon="âœï¸")
st.title("âœï¸ å®¡é¢˜èƒ½åŠ›è®­ç»ƒ")


# --- è¾…åŠ©å‡½æ•° ---
def get_answer_letters(selection):
    """ä»ç”¨æˆ·çš„é€‰æ‹©ï¼ˆå­—ç¬¦ä¸²æˆ–åˆ—è¡¨ï¼‰ä¸­æå–å‡ºå¤§å†™å­—æ¯ç­”æ¡ˆã€‚"""
    if not selection:
        return []

    if isinstance(selection, str):
        selection = [selection]

    letters = []
    for item in selection:
        match = re.match(r"([A-Z])", item)
        if match:
            letters.append(match.group(1))
    return sorted(letters)


def display_feedback_for_step(step_name, problem_data, user_answers_data, step_results_data):
    """ä¸€ä¸ªä¸“é—¨ç”¨äºæ˜¾ç¤ºæ¯ä¸€æ­¥åé¦ˆçš„å‡½æ•°ï¼Œä»¥æä¾›æ›´ä¸°å¯Œçš„ä¸Šä¸‹æ–‡ã€‚"""

    # æå–æ‰€éœ€ä¿¡æ¯
    question = problem_data[f'{step_name}_Question']
    all_options = str(problem_data[f'{step_name}_Options']).split('|')
    step_result = step_results_data.get(step_name, {})

    user_letters = step_result.get('user_letters', [])
    correct_letters = step_result.get('correct_answers', [])
    is_correct = step_result.get('correct', False)

    st.markdown("---")
    st.markdown(
        f"**{['ä¸€', 'äºŒ', 'ä¸‰', 'å››'][['Goal', 'Extraction', 'Rule', 'Strategy'].index(step_name)]}ã€{question}**")

    # é€ä¸€æ¸²æŸ“æ‰€æœ‰é€‰é¡¹ï¼Œå¹¶æ ‡è®°ç”¨æˆ·é€‰æ‹©å’Œæ­£ç¡®æ€§
    for option in all_options:
        option_letter = get_answer_letters(option)[0]
        is_selected = option_letter in user_letters
        is_correct_option = option_letter in correct_letters

        # æ ¹æ®çŠ¶æ€é€‰æ‹©ä¸åŒçš„å›¾æ ‡å’Œæ ¼å¼
        if is_selected and is_correct_option:
            st.markdown(f"ğŸ”µ **{option}** (ä½ çš„é€‰æ‹© - æ­£ç¡®)")
        elif is_selected and not is_correct_option:
            st.markdown(f"ğŸ”´ **{option}** (ä½ çš„é€‰æ‹© - é”™è¯¯)")
        elif not is_selected and is_correct_option:
            st.markdown(f"âœ… **{option}** (æ­£ç¡®ç­”æ¡ˆ)")
        else:
            st.markdown(f"âšª {option}")

    # æ˜¾ç¤ºæ€»ä½“å¯¹é”™åˆ¤æ–­å’Œæ¥è‡ªFeedback_Columnçš„å»ºè®®
    if is_correct:
        st.success("âœ… **å›ç­”æ­£ç¡®**")
    else:
        st.error("âŒ **å›ç­”é”™è¯¯**")

        # è§£æå¹¶æ˜¾ç¤ºFeedback_Columnä¸­çš„å…·ä½“å»ºè®®
        try:
            feedback_data = json.loads(problem_data['Feedback_Column'])

            # æ‰¾å‡ºæ‰€æœ‰é”™è¯¯ç›¸å…³çš„é€‰é¡¹å­—æ¯ï¼ˆé€‰äº†ä½†é”™è¯¯ + æ²¡é€‰ä½†æ­£ç¡®ï¼‰
            error_related_letters = set(user_letters).symmetric_difference(set(correct_letters))

            for letter in error_related_letters:
                feedback_key = f"{step_name}_{letter}"
                if feedback_key in feedback_data:
                    st.warning(f"ğŸ’¡ **é’ˆå¯¹é€‰é¡¹ {letter} çš„å»ºè®®:** {feedback_data[feedback_key]}")

        except (json.JSONDecodeError, KeyError):
            # å¦‚æœFeedback_Columnä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯ï¼Œåˆ™ä¸æ˜¾ç¤ºå»ºè®®
            pass


# --- çŠ¶æ€åˆå§‹åŒ– ---
# (ä¿æŒä¸å˜)
if 'comp_level' not in st.session_state:
    st.session_state.comp_level = 0
    st.session_state.problems = []
    st.session_state.current_problem_index = 0
    st.session_state.session_correct_subquestion_count = 0
    st.session_state.session_problem_count = 0
    st.session_state.submitted = False
    st.session_state.timed_out = False
    st.session_state.comp_start_time = 0
    st.session_state.user_answers_for_feedback = {}
    st.session_state.step_results = {}

# --- é¡µé¢é€»è¾‘ ---

# éš¾åº¦é€‰æ‹©
# (ä¿æŒä¸å˜)
if st.session_state.comp_level == 0:
    st.info("è¯·é€‰æ‹©éš¾åº¦å¼€å§‹è®­ç»ƒã€‚æ¯è½®è®­ç»ƒåŒ…å«3é“é¢˜ç›®ï¼Œæ¯é¢˜éƒ½æœ‰æ—¶é—´é™åˆ¶ã€‚")
    level_options = {1: "ç­‰çº§ 1 (æ¯é¢˜60ç§’)", 2: "ç­‰çº§ 2 (æ¯é¢˜90ç§’)", 3: "ç­‰çº§ 3 (æ¯é¢˜120ç§’)"}
    level = st.selectbox("é€‰æ‹©éš¾åº¦ç­‰çº§", options=list(level_options.keys()), format_func=lambda x: level_options[x])

    if st.button("å¼€å§‹æ–°ä¸€è½®è®­ç»ƒ"):
        problems = load_problems(level)
        if problems and len(problems) >= 3:
            # é‡ç½®æ‰€æœ‰çŠ¶æ€
            st.session_state.comp_level = level
            st.session_state.problems = problems[:3]
            st.session_state.current_problem_index = 0
            st.session_state.session_correct_subquestion_count = 0
            st.session_state.session_problem_count = 0
            st.session_state.submitted = False
            st.session_state.timed_out = False
            st.session_state.comp_start_time = time.time()
            st.rerun()
        else:
            st.error("åŠ è½½é¢˜åº“å¤±è´¥æˆ–é¢˜åº“é¢˜ç›®ä¸è¶³3é“ï¼Œè¯·æ£€æŸ¥dataæ–‡ä»¶å¤¹ã€‚")

# è®­ç»ƒæ€»ç»“
# (ä¿æŒä¸å˜)
elif st.session_state.comp_level == -1:
    st.balloons()
    st.subheader("ğŸ‰ æœ¬è½®è®­ç»ƒå·²å®Œæˆï¼")
    total_subquestions = st.session_state.session_problem_count * 4
    try:
        accuracy = st.session_state.session_correct_subquestion_count / total_subquestions
        st.metric("å°é¢˜æ­£ç¡®ç‡", f"{accuracy:.1%}")
        st.info(
            f"åœ¨æœ¬è½®æ€»å…± **{total_subquestions}** é“åˆ†æå°é¢˜ä¸­ï¼Œä½ ç­”å¯¹äº† **{st.session_state.session_correct_subquestion_count}** é“ã€‚")
    except ZeroDivisionError:
        st.warning("æœ¬è½®æœªå®Œæˆä»»ä½•é¢˜ç›®ã€‚")

    if st.button("å†æ¥ä¸€ç»„ï¼"):
        st.session_state.comp_level = 0
        st.rerun()

# è®­ç»ƒä¸»ç•Œé¢
else:
    problem = st.session_state.problems[st.session_state.current_problem_index]
    time_limits = {1: 60, 2: 90, 3: 120}
    time_limit = time_limits[st.session_state.comp_level]

    # --- è®¡æ—¶å™¨é€»è¾‘ (ä¿æŒä¸å˜) ---
    if not st.session_state.submitted:
        # ... (æ­¤å¤„ä»£ç çœç•¥ï¼Œä¸ä¸Šä¸€ç‰ˆç›¸åŒ) ...
        time_elapsed = time.time() - st.session_state.comp_start_time
        time_left = time_limit - time_elapsed
        timer_placeholder = st.empty()
        timer_placeholder.progress(max(0, time_left) / time_limit, text=f"å‰©ä½™æ—¶é—´: {max(0, int(time_left))} ç§’")
        if time_left < 0:
            st.session_state.submitted = True
            st.session_state.timed_out = True
            st.rerun()

    # --- ç•Œé¢å¸ƒå±€ ---
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("é¢˜ç›®åŸæ–‡")
        st.markdown(f"**ç¬¬ {st.session_state.session_problem_count + 1} / 3 é¢˜** (ID: {problem['Problem_ID']})")
        st.markdown(problem['Problem_Text'])

    with col2:
        # --- ç­”é¢˜è¡¨å• ---
        if not st.session_state.submitted:
            st.subheader("è¯·ä¸€æ¬¡æ€§å®Œæˆä»¥ä¸‹æ‰€æœ‰åˆ†ææ­¥éª¤")
            with st.form(key='comprehension_form'):
                steps = ["Goal", "Extraction", "Rule", "Strategy"]
                questions = [problem[f'{s}_Question'] for s in steps]
                options_list = [str(problem[f'{s}_Options']).split('|') for s in steps]

                user_answers = {}
                user_answers['Goal'] = st.radio(f"**1. {questions[0]}**", options_list[0], key='goal_radio')
                user_answers['Extraction'] = st.multiselect(f"**2. {questions[1]}**", options_list[1], key='ext_multi')
                user_answers['Rule'] = st.multiselect(f"**3. {questions[2]}**", options_list[2], key='rule_multi')
                user_answers['Strategy'] = st.radio(f"**4. {questions[3]}**", options_list[3], key='strat_radio')

                submitted_button = st.form_submit_button("æäº¤æœ¬é¢˜å…¨éƒ¨ç­”æ¡ˆ")

                if submitted_button:
                    st.session_state.submitted = True
                    st.session_state.user_answers_for_feedback = user_answers

                    # --- æäº¤æ—¶ç«‹å³å¤„ç†ç­”æ¡ˆå’Œåˆ†æ•° ---
                    step_results = {}
                    correct_sub_count_this_round = 0
                    for step in steps:
                        correct_answers = sorted(str(problem[f'{step}_Answer']).split('|'))
                        user_selection = user_answers.get(step, [])
                        user_letters = get_answer_letters(user_selection)

                        is_step_correct = (user_letters == correct_answers)
                        if is_step_correct:
                            correct_sub_count_this_round += 1

                        step_results[step] = {
                            "correct": is_step_correct,
                            "user_letters": user_letters,
                            "correct_answers": correct_answers
                        }

                    st.session_state.step_results = step_results
                    st.session_state.session_correct_subquestion_count += correct_sub_count_this_round
                    st.session_state.session_problem_count += 1
                    st.rerun()

        # --- åé¦ˆç•Œé¢ (é‡å¤§ä¿®æ”¹) ---
        else:
            st.subheader("ç­”æ¡ˆä¸è§£æ")
            if st.session_state.timed_out:
                st.error("âŒ›ï¸ æ—¶é—´åˆ°ï¼æœ¬é¢˜æ‰€æœ‰å°é¢˜è®¡ä¸ºé”™è¯¯ã€‚")

            # ä½¿ç”¨æ–°çš„è¾…åŠ©å‡½æ•°æ¥æ˜¾ç¤ºæ¯ä¸€æ­¥çš„è¯¦ç»†åé¦ˆ
            for step in ["Goal", "Extraction", "Rule", "Strategy"]:
                display_feedback_for_step(
                    step_name=step,
                    problem_data=problem,
                    user_answers_data=st.session_state.get('user_answers_for_feedback', {}),
                    step_results_data=st.session_state.get('step_results', {})
                )

            st.markdown("---")


            # --- æµç¨‹æ§åˆ¶æŒ‰é’® ---
            def go_to_next_problem():
                if st.session_state.session_problem_count >= 3:
                    st.session_state.comp_level = -1
                else:
                    st.session_state.current_problem_index += 1
                    st.session_state.submitted = False
                    st.session_state.timed_out = False
                    st.session_state.step_results = {}
                    st.session_state.user_answers_for_feedback = {}
                    st.session_state.comp_start_time = time.time()


            st.button("è¿›å…¥ä¸‹ä¸€é¢˜" if st.session_state.session_problem_count < 3 else "æŸ¥çœ‹æœ¬è½®æ€»ç»“",
                      on_click=go_to_next_problem)

    # ä¿æŒè®¡æ—¶å™¨UIå®æ—¶åˆ·æ–°
    if not st.session_state.submitted and st.session_state.comp_level > 0:
        time.sleep(0.1)
        st.rerun()