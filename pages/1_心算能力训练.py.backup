# pages/1_心算能力训练.py

# ==============================================================================
# 1. 导入所需库
# ==============================================================================
# 导入streamlit库，它是构建这个Web应用界面的核心框架，通常简写为st
import streamlit as st
# 从我们自己编写的`modules/calculator_logic.py`文件中，导入用于生成数学题的函数
from modules.calculator_logic import generate_math_problem
# 导入Python内置的time库，用于处理时间相关的操作，如此处的计时器功能
import time

# ==============================================================================
# 2. 页面基础配置
# ==============================================================================
# `st.set_page_config` 用于设置网页标签（Tab）的基本属性。
# 这条命令应该是脚本中第一个被执行的Streamlit命令。
st.set_page_config(
    page_title="心算能力训练",  # 设置浏览器标签页上显示的标题
    page_icon="🧮"  # 设置浏览器标签页上显示的图标
)

# `st.title` 用于在应用的主页面上显示一个大标题
st.title("🧮 心算能力训练")

# ==============================================================================
# 3. 会话状态 (Session State) 初始化
# ==============================================================================
# Streamlit应用的脚本在每次用户交互后都会从头到尾重新运行。
# `st.session_state` 是一个特殊的字典式对象，用于在多次运行之间保存数据。
# 下面的代码块检查某个关键变量是否存在，如果不存在，则意味着是用户首次加载页面，
# 此时需要初始化所有我们将用到的状态变量。

if 'calc_level' not in st.session_state:
    # `calc_level` 用于控制当前的游戏状态：
    # 0  : 初始状态，显示难度选择界面
    # >0 : 游戏进行中，值为1-6，代表不同难度
    # -1 : 游戏结束，显示总结界面
    st.session_state.calc_level = 0

    # `calc_score` 用于记录玩家的得分
    st.session_state.calc_score = 0

    # `calc_questions_answered` 用于记录已经回答了多少道题
    st.session_state.calc_questions_answered = 0

    # `current_problem` 用于存储当前显示的题目字符串
    st.session_state.current_problem = ""

    # `current_answer` 用于存储当前题目的正确答案
    st.session_state.current_answer = None

    # `last_feedback` 用于存储上一题的反馈信息（正确或错误提示）
    st.session_state.last_feedback = ""

    # `start_time` 用于记录当前题目开始的时间戳，以便计算剩余时间
    st.session_state.start_time = 0

# ==============================================================================
# 4. 界面渲染逻辑分发
# 根据 `calc_level` 的值，决定显示哪个界面
# ==============================================================================

# ------------------------------------------------------------------------------
# 4.1. 显示难度选择界面
# ------------------------------------------------------------------------------
# 如果 `calc_level` 为 0，说明游戏还未开始，显示难度选择按钮。
if st.session_state.calc_level == 0:
    # `st.info` 在页面上显示一个蓝色的信息框，用于提供说明。
    st.info("请选择一个难度等级开始训练。每道题都有时间限制！")

    # `st.columns(3)` 创建一个包含3个列的网格布局，让按钮排列更美观。
    cols = st.columns(3)
    # `levels` 列表存储了6个难度按钮上要显示的文本。
    levels = ["等级1 (5秒)", "等级2 (10秒)", "等级3 (15秒)", "等级4 (20秒)", "等级5 (25秒)", "等级6 (30秒)"]

    # `enumerate` 函数可以同时遍历列表的索引 `i` 和元素 `level_desc`。
    for i, level_desc in enumerate(levels):
        # `i % 3` 的结果会在 0, 1, 2 之间循环，这样按钮就会依次放入3个列中。
        # `st.button` 创建一个按钮。当用户点击这个按钮时，这个if条件判断为True。
        # `key` 是每个UI组件的唯一标识符，对于循环中创建的组件，设置唯一的key至关重要。
        if cols[i % 3].button(level_desc, key=f"level_{i + 1}"):
            # --- 以下是用户点击难度按钮后执行的逻辑 ---
            # 1. 设置游戏等级
            st.session_state.calc_level = i + 1
            # 2. 重置游戏数据
            st.session_state.calc_score = 0
            st.session_state.calc_questions_answered = 0
            st.session_state.last_feedback = ""
            # 3. 生成第一道题
            problem, answer = generate_math_problem(st.session_state.calc_level)
            st.session_state.current_problem = problem
            st.session_state.current_answer = answer
            # 4. 记录游戏开始时间
            st.session_state.start_time = time.time()
            # 5. `st.rerun()` 强制页面立即重新加载。此时`calc_level`已不再为0，页面将显示游戏主界面。
            st.rerun()

# ------------------------------------------------------------------------------
# 4.2. 显示游戏主界面
# ------------------------------------------------------------------------------
# 如果 `calc_level` 不为 0，则进入此分支，显示游戏相关内容。
else:
    # 根据当前等级计算每道题的时间限制
    time_limit = st.session_state.calc_level * 5

    # `st.subheader` 创建一个二级标题，显示当前等级。
    st.subheader(f"等级 {st.session_state.calc_level}")
    # 创建两列来分别显示得分和进度。
    score_col, progress_col = st.columns(2)
    # `st.metric` 是一个专门用于展示关键指标的组件，有标题、数值和可选的增减量。
    score_col.metric("得分", st.session_state.calc_score)
    progress_col.metric("进度", f"{st.session_state.calc_questions_answered} / 20")

    # `st.markdown("---")` 在页面上渲染一条水平分割线。
    st.markdown("---")

    # `st.header` 创建一个三级标题，用于显示题目。
    # 文本两侧的反引号 `` 会让Streamlit使用等宽字体渲染，适合显示代码或算式。
    st.header(f"`{st.session_state.current_problem} = ?`")


    # --- 定义核心逻辑函数 ---

    # `handle_answer` 函数负责处理答案的判断、分数的更新以及新题目的生成。
    def handle_answer(is_correct, reason=""):
        # 如果答案正确...
        if is_correct:
            st.session_state.calc_score += 10  # 分数加10
            st.session_state.last_feedback = "正确！🎉"  # 设置正确的反馈信息
        # 如果答案错误...
        else:
            correct_answer = st.session_state.current_answer
            st.session_state.last_feedback = f"{reason} 正确答案是: {correct_answer} 💪"

        # 不论对错，已回答题目数都加1
        st.session_state.calc_questions_answered += 1
        # 如果20题还没答完...
        if st.session_state.calc_questions_answered < 20:
            # 生成新题目
            problem, answer = generate_math_problem(st.session_state.calc_level)
            st.session_state.current_problem = problem
            st.session_state.current_answer = answer
            st.session_state.start_time = time.time()  # 为新题目重置计时器
        # 如果20题已全部答完...
        else:
            # 设置游戏状态为-1，表示游戏结束
            st.session_state.calc_level = -1


    # `handle_submit` 函数作为输入框的回调，在用户提交答案时被触发。
    def handle_submit():
        try:
            # `st.session_state.user_input` 会自动获取输入框中的值
            user_answer = int(st.session_state.user_input)
            # 调用 `handle_answer` 函数进行判断
            handle_answer(user_answer == st.session_state.current_answer, "回答错误！")
        except (ValueError, TypeError):
            # 如果用户输入的内容无法转换为整数（例如输入了字母），则判为无效输入
            handle_answer(False, "输入无效！")

        # 提交后清空输入框，方便用户输入下一题答案
        st.session_state.user_input = ""


    # --- 创建UI组件 ---

    # `st.empty()` 创建一个空的容器（占位符），后续可以用代码向其中动态填入内容。
    feedback_placeholder = st.empty()
    # 如果 `last_feedback` 不为空（即非第一题），则显示反馈信息。
    if st.session_state.last_feedback:
        # 根据反馈内容是包含“正确”还是“错误”，来显示不同颜色的提示框。
        if "正确" in st.session_state.last_feedback:
            feedback_placeholder.success(st.session_state.last_feedback)  # 绿色成功框
        else:
            feedback_placeholder.error(st.session_state.last_feedback)  # 红色错误框

    # `st.text_input` 创建一个文本输入框。
    # `on_change=handle_submit` 是一个回调设置，表示当输入框内容改变且用户按下回车时，自动调用`handle_submit`函数。
    # `disabled` 参数用于控制组件是否可交互。当游戏结束时(`calc_level`为-1)，禁用输入框。
    st.text_input("请输入你的答案:", key="user_input", on_change=handle_submit,
                  disabled=(st.session_state.calc_level == -1))

    # --- 计时器与自动刷新逻辑 ---

    # 只有在游戏进行中 (`calc_level` > 0) 才执行计时和刷新逻辑。
    if st.session_state.calc_level > 0:
        # 计算已过时间和剩余时间
        time_elapsed = time.time() - st.session_state.start_time
        time_left = time_limit - time_elapsed

        # 创建一个占位符用于显示进度条
        timer_placeholder = st.empty()
        # `st.progress` 创建一个进度条，第一个参数是0到1之间的小数，表示进度百分比。
        timer_placeholder.progress(max(0, time_left) / time_limit, text=f"剩余时间: {max(0, int(time_left))} 秒")

        # 如果时间用完...
        if time_left < 0:
            handle_answer(False, "超时！")  # 调用处理函数，判为超时错误
            st.rerun()  # 立即刷新页面以显示下一题

        # 这是一个实现“实时”动画效果的技巧
        time.sleep(0.1)  # 让程序暂停0.1秒，以降低CPU占用率
        st.rerun()  # 强制页面刷新，从而不断更新进度条和剩余时间显示

    # ------------------------------------------------------------------------------
    # 4.3. 显示游戏结束界面
    # ------------------------------------------------------------------------------
    # 当游戏状态为-1时，执行此代码块。
    elif st.session_state.calc_level == -1:
        # `st.balloons()` 在页面上显示一个庆祝的彩带动画。
        st.balloons()
        # 显示最终得分。
        st.success(f"训练完成！你的最终得分是: {st.session_state.calc_score}")
        # 提供一个按钮让用户返回难度选择界面。
        if st.button("返回难度选择"):
            st.session_state.calc_level = 0  # 将状态重置为初始状态
            st.rerun()  # 刷新页面，此时将显示难度选择界面