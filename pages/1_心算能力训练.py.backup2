# pages/1_心算能力训练.py
# import streamlit as st; st.error("这是一个强制测试信息，如果看到它，说明您正在运行最新的文件。")
# ==============================================================================
# 1. 导入所需库
# ==============================================================================
import streamlit as st
from modules.calculator_logic import generate_math_problem
import time

# ==============================================================================
# 2. 页面基础配置
# ==============================================================================
st.set_page_config(
    page_title="心算能力训练",
    page_icon="🧮"
)
st.title("🧮 心算能力训练")

# ==============================================================================
# 3. 会话状态 (Session State) 初始化
# ==============================================================================
if 'calc_level' not in st.session_state:
    st.session_state.calc_level = 0  # 0: 待选择, >0: 游戏中, -1: 游戏结束
    st.session_state.calc_score = 0
    st.session_state.calc_questions_answered = 0
    st.session_state.current_problem = ""
    st.session_state.current_answer = None
    st.session_state.last_feedback = ""
    st.session_state.start_time = 0


# ==============================================================================
# 4. 界面渲染函数 (使用函数封装实现UI隔离)
# ==============================================================================

def select_level(level_choice):
    """
    这是一个回调函数，当用户点击难度按钮时被触发。
    它负责安全地更新所有相关的会话状态，为游戏做准备。
    """
    st.session_state.calc_level = level_choice
    st.session_state.calc_score = 0
    st.session_state.calc_questions_answered = 0
    st.session_state.last_feedback = ""
    if level_choice > 0:  # 只有在选择新游戏时才生成题目
        problem, answer = generate_math_problem(st.session_state.calc_level)
        st.session_state.current_problem = problem
        st.session_state.current_answer = answer
        st.session_state.start_time = time.time()


def show_difficulty_selection():
    """专门负责显示难度选择界面的函数"""
    st.info("请选择一个难度等级开始训练。每道题都有时间限制！")

    cols = st.columns(3)
    levels = ["等级1 (5秒)", "等级2 (10秒)", "等级3 (15秒)", "等级4 (20秒)", "等级5 (25秒)", "等级6 (30秒)"]

    for i, level_desc in enumerate(levels):
        # 核心修改：使用 on_click 参数绑定回调函数，这是最稳健的方式
        cols[i % 3].button(
            level_desc,
            key=f"level_{i + 1}",
            on_click=select_level,
            args=(i + 1,)  # 将要设置的等级 (i+1) 作为参数传给回调函数
        )


def show_game_interface():
    """专门负责显示游戏主界面的函数"""
    st.info(f"当前的游戏等级(calc_level)是: {st.session_state.calc_level}")

    time_limit = st.session_state.calc_level * 5

    st.subheader(f"等级 {st.session_state.calc_level}")
    score_col, progress_col = st.columns(2)
    score_col.metric("得分", st.session_state.calc_score)
    progress_col.metric("进度", f"{st.session_state.calc_questions_answered} / 20")

    st.markdown("---")
    st.header(f"`{st.session_state.current_problem} = ?`")

    def handle_answer(is_correct, reason=""):
        if is_correct:
            st.session_state.calc_score += 10
            st.session_state.last_feedback = "正确！🎉"
        else:
            correct_answer = st.session_state.current_answer
            st.session_state.last_feedback = f"{reason} 正确答案是: {correct_answer} 💪"

        st.session_state.calc_questions_answered += 1
        if st.session_state.calc_questions_answered < 20:
            problem, answer = generate_math_problem(st.session_state.calc_level)
            st.session_state.current_problem = problem
            st.session_state.current_answer = answer
            st.session_state.start_time = time.time()
        else:
            st.session_state.calc_level = -1

    def handle_submit():
        try:
            user_answer = int(st.session_state.user_input)
            handle_answer(user_answer == st.session_state.current_answer, "回答错误！")
        except (ValueError, TypeError):
            if st.session_state.user_input != "": handle_answer(False, "输入无效！")
        st.session_state.user_input = ""

    feedback_placeholder = st.empty()
    if st.session_state.last_feedback:
        if "正确" in st.session_state.last_feedback:
            feedback_placeholder.success(st.session_state.last_feedback)
        else:
            feedback_placeholder.error(st.session_state.last_feedback)

    st.text_input("请输入你的答案:", key="user_input", on_change=handle_submit)

    time_elapsed = time.time() - st.session_state.start_time
    time_left = time_limit - time_elapsed

    timer_placeholder = st.empty()
    timer_placeholder.progress(max(0, time_left) / time_limit, text=f"剩余时间: {max(0, int(time_left))} 秒")

    if time_left < 0:
        handle_answer(False, "超时！")
        st.rerun()

    time.sleep(0.1)
    st.rerun()


def show_game_over_screen():
    """专门负责显示游戏结束界面的函数"""
    st.balloons()
    st.success(f"训练完成！你的最终得分是: {st.session_state.calc_score}")
    # 使用 on_click 重置状态，返回主菜单
    st.button("返回难度选择", on_click=select_level, args=(0,))


# ==============================================================================
# 5. 主逻辑分发器
# ==============================================================================
# 这个 if/elif/else 结构确保了在任何时候，只有一个界面函数会被执行
if st.session_state.calc_level == 0:
    show_difficulty_selection()
elif st.session_state.calc_level == -1:
    show_game_over_screen()
else:  # calc_level is > 0
    show_game_interface()